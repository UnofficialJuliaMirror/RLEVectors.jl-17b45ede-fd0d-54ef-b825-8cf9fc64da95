{
    "docs": [
        {
            "location": "/", 
            "text": "RLEVectors\n\n\nRLEVectors\n is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types are  measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.\n\n\n\n\nBackground\n\n\nBioconductor has some widely used and extremely convenient types for working with collections of ranges, which sometimes are with associated data.\nIRanges\n represents a collection of arbitrary start, end pairs in [1,Inf). \nGRanges\n uses \nIRanges\n to represent locations on a genome and adds annotation of the chromosome and strand for each range. Children of \nGRanges\n add other annotations the the ranges. \nRle\n represents the range [1:n] broken into arbitrary chunks or segments.\n\n\n\n\nImplementation Details\n\n\nRLEVectors\n differs from R's \nRle\n in that we store the run values and run ends rather than the run values and run lengths. The run ends are convenient in that they allow for indexing into the vector by binary search (scalar indexing is O(log(n)) rather than O(n) ). Additionally, \nlength\n is O(1) rather than O(n) (it's the last run end rather than the sum of the run lengths). On the other hand, various operations do require the run lengths, which have to be calculated. See the benchmark directory and reports to see how this plays out.\n\n\n\n\nCreation\n\n\nRLEVectors\n can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector like a \nRange\n with \ncollect\n.\n\n\nusing RLEVectors\nx = RLEVector([1,1,2,2,3,3,4,4,4])\ncollect(x)\ny = RLEVector([4,5,6],[3,6,9])\ncollect(y)\n\n\n\n\n9-element Array{Int64,1}:\n 4\n 4\n 4\n 5\n 5\n 5\n 6\n 6\n 6\n\n\n\n\n\n\nDescribing\n\n\nRLEVectors implement the standard Vector API and also other methods for describing the ranges and values:\n\n\n\n\nlength(x)\n # The full length of the vector, uncompressed\n\n\nnrun(x)\n # The number of runs in the vector\n\n\nrstart(x)\n # The index of the beginning of each run\n\n\nrwidth(x)\n # The width of each run\n\n\nrstart(x)\n # The index of the end of each run\n\n\n\n\nNaming for some of these functions is difficult given that many useful names are already reserved words (\nend\n, \nstart\n, \nlast\n). Suggestions are welcome at this stage of development.\n\n\n\n\nStandard vector operations\n\n\nRLEVector\ns can be treated as standard Vectors for arithmetic and collection operations. In many cases these operations are more efficient than operations on a standard vector.\n\n\n\n\nx = RLEVector([4,5,6],[3,6,9])\n\n\nx[2]\n\n\nx[7:9] = 10\n\n\npush!(x,6)\n\n\nx + 2x\n\n\nunique(x)\n\n\nfindin(x,5)\n\n\nx \n 4.2\n\n\nsort(x)\n\n\nmedian(x)\n\n\n\n\n\n\nRelative speed\n\n\nRLEVectors\n has been extensively profiled and somewhat optimized. Please see the benchmarking section for the evolution over time and comparisons to like operations in R.\n\n\n\n\nBenchmarks\n\n\n Please note that these benchmarks include data structure / algorithmic differences as well as language differences \n For example, indexing is O( log(n) ) in RLEVectors.jl and O(n) in the original R implementation. Similarly, \nlast\n is a simple lookup in RLEVectors.jl where \nwidth\n is a lookup in the R version. Other functions listed here of the same computational order, but not necessarily direct translations. RLEVectors.jl is written in my interpretation of idiomatic julia.\n\n\n\n\n\n\nOptimization progress\n\n\n\n\n\n\nMemory considerations\n\n\nData compression is a secondary benefit of \nRLEVector\ns, but it can be convenient. Generally run ends are stored as Int64. However, if further memory savings are desired, consider smaller and unsigned types. UInt32 is sufficient to hold the length of the human genome and UInt16 can hold the length of the longest human chromosome.\n\n\nRLEVector([5.1,2.9,100.7], UInt16[4,8,22])", 
            "title": "Home"
        }, 
        {
            "location": "/#rlevectors", 
            "text": "RLEVectors  is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types are  measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.", 
            "title": "RLEVectors"
        }, 
        {
            "location": "/#background", 
            "text": "Bioconductor has some widely used and extremely convenient types for working with collections of ranges, which sometimes are with associated data. IRanges  represents a collection of arbitrary start, end pairs in [1,Inf).  GRanges  uses  IRanges  to represent locations on a genome and adds annotation of the chromosome and strand for each range. Children of  GRanges  add other annotations the the ranges.  Rle  represents the range [1:n] broken into arbitrary chunks or segments.", 
            "title": "Background"
        }, 
        {
            "location": "/#implementation-details", 
            "text": "RLEVectors  differs from R's  Rle  in that we store the run values and run ends rather than the run values and run lengths. The run ends are convenient in that they allow for indexing into the vector by binary search (scalar indexing is O(log(n)) rather than O(n) ). Additionally,  length  is O(1) rather than O(n) (it's the last run end rather than the sum of the run lengths). On the other hand, various operations do require the run lengths, which have to be calculated. See the benchmark directory and reports to see how this plays out.", 
            "title": "Implementation Details"
        }, 
        {
            "location": "/#creation", 
            "text": "RLEVectors  can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector like a  Range  with  collect .  using RLEVectors\nx = RLEVector([1,1,2,2,3,3,4,4,4])\ncollect(x)\ny = RLEVector([4,5,6],[3,6,9])\ncollect(y)  9-element Array{Int64,1}:\n 4\n 4\n 4\n 5\n 5\n 5\n 6\n 6\n 6", 
            "title": "Creation"
        }, 
        {
            "location": "/#describing", 
            "text": "RLEVectors implement the standard Vector API and also other methods for describing the ranges and values:   length(x)  # The full length of the vector, uncompressed  nrun(x)  # The number of runs in the vector  rstart(x)  # The index of the beginning of each run  rwidth(x)  # The width of each run  rstart(x)  # The index of the end of each run   Naming for some of these functions is difficult given that many useful names are already reserved words ( end ,  start ,  last ). Suggestions are welcome at this stage of development.", 
            "title": "Describing"
        }, 
        {
            "location": "/#standard-vector-operations", 
            "text": "RLEVector s can be treated as standard Vectors for arithmetic and collection operations. In many cases these operations are more efficient than operations on a standard vector.   x = RLEVector([4,5,6],[3,6,9])  x[2]  x[7:9] = 10  push!(x,6)  x + 2x  unique(x)  findin(x,5)  x   4.2  sort(x)  median(x)", 
            "title": "Standard vector operations"
        }, 
        {
            "location": "/#relative-speed", 
            "text": "RLEVectors  has been extensively profiled and somewhat optimized. Please see the benchmarking section for the evolution over time and comparisons to like operations in R.", 
            "title": "Relative speed"
        }, 
        {
            "location": "/#benchmarks", 
            "text": "Please note that these benchmarks include data structure / algorithmic differences as well as language differences   For example, indexing is O( log(n) ) in RLEVectors.jl and O(n) in the original R implementation. Similarly,  last  is a simple lookup in RLEVectors.jl where  width  is a lookup in the R version. Other functions listed here of the same computational order, but not necessarily direct translations. RLEVectors.jl is written in my interpretation of idiomatic julia.", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/#optimization-progress", 
            "text": "", 
            "title": "Optimization progress"
        }, 
        {
            "location": "/#memory-considerations", 
            "text": "Data compression is a secondary benefit of  RLEVector s, but it can be convenient. Generally run ends are stored as Int64. However, if further memory savings are desired, consider smaller and unsigned types. UInt32 is sufficient to hold the length of the human genome and UInt16 can hold the length of the longest human chromosome.  RLEVector([5.1,2.9,100.7], UInt16[4,8,22])", 
            "title": "Memory considerations"
        }, 
        {
            "location": "/NEWS/", 
            "text": "Version 0.0.0\n\n\nSuper-duper dev mode. Basically, don't use this.\n\n\n\n\nVersion 0.0.1\n\n\nFeature complete, full test coverage, all tests pass.\n\n\n\n\nVersion 0.1.0\n\n\nAll TODO items for 0.1.0 done including basic vignette / README. More optimizations and tests.", 
            "title": "Changelog"
        }, 
        {
            "location": "/NEWS/#version-000", 
            "text": "Super-duper dev mode. Basically, don't use this.", 
            "title": "Version 0.0.0"
        }, 
        {
            "location": "/NEWS/#version-001", 
            "text": "Feature complete, full test coverage, all tests pass.", 
            "title": "Version 0.0.1"
        }, 
        {
            "location": "/NEWS/#version-010", 
            "text": "All TODO items for 0.1.0 done including basic vignette / README. More optimizations and tests.", 
            "title": "Version 0.1.0"
        }, 
        {
            "location": "/TODO/", 
            "text": "TODO list\n\n\n\n\nNew types\n\n\n\n\n[ ] Vector{RLEVector} called RLEVectorList (RVL) with group_generics that loop over elements and match elements when given two RLEs\n\n\n[ ] RLEDataFrame based on RLEVectorList\n\n\n[ ] RVL implements all RLEVector functions as map(x,rvl)\n\n\n[ ] which functions apply to the list and which map over the elements?\n\n\n[ ] RLEDF needs the same creation functions as DataFrame\n\n\n\n\n\n\n0.5 changes\n\n\n\n\n[x] Base.:(symbol) should now be Base.:symbol, requiring some changes in group_generics.jl\n\n\n[x] BaseTestNext\n\n\n[x] different show for MIME type for printing in REPL\n\n\n\n\n\n\nEnhancements\n\n\n\n\n[ ] Figure out how Documenter and doctests work together\n\n\n[ ] for f in  [:sum, :prod, :mean, :var, :std] @eval mapslices(f::typeof(:f), A, dims) = :f(A, dims) end\n\n\n[ ] Make Runs type, split from and use in RLEVector\n\n\n[x] pretty \nshow\n with elipsis if length \n 6, show runs and also expanded vector, use utils.rep\n\n\n[x] Add benchmark/ with R and .jl scripts comparing timings on some common things. Have one read a CSV from the other and plot.\n\n\n[ ] outer constructor for RLEVectors that takes runends or vector and then optional named args runends and runwidths\n\n\n[ ] Can I make a special zip-like loop that runs over the disjoint runs of 2+ RLEVectors and the associated values?\n\n\n[ ] vcat with splat for multiple args (vararg vcat)\n\n\n[x] deleterun! should give a ree'd RLEVector, check for newly adjacent runs, use deleteat![x,itr] if necessary\n\n\n[x] Any other function groups from DataArrays that I need?\n\n\n[x] factor out run counting stuff in ree(Vector) and disjoin, call it \nnrun\n\n\n[x] implement comparison operators \n=, etc.\n\n\n[x] Rle to set conversion\n\n\n[ ] iterator versions of rwidth and rstart. Allocation is the root of all evil. Allocation in rwidth seems to be the bulk of 'median' at this point, for example.\n\n\n[x] ind2runcontext for UnitRange, use for setindex(x::RLEVector, value, indices::UnitRange)\n\n\n[x] Make sure this works with Julia V0.4. Likely we have some tuple trouble and the tests will be riddled with the Range expansion change ([1:4] is a 1-vector of Ranges rather than [1,2,3,4]).\n\n\n[x] function documentation section: describing\n\n\n[x] function documentation section: creating\n\n\n[x] function documentation section: range functions\n\n\n[ ] get ree and vcat out of splice\n\n\n[ ] iterator called 'ranges' that gives (first,last) indices for runs. Will require a new type with the 3 iterator methods, say RLERangesIterator.\n\n\n[x] Make sure my hash and == are what AutoHashEquals would say\n\n\n[ ] linalg operations\n\n\n[ ] make 'each' a Task?\n\n\n[ ] make disjoin Task for two RLEs?\n\n\n[ ] faster group_generic operations based on disjoin\n\n\n[ ] Some way to disjoin two RLEs such that the runends are made identical, with some repeated runvalues (necessarily). Should it be OK have an RLE be less than fully compressed? Would 'ree' then re-compress it?\n\n\n[x] test for ind2run(rle::RLEVector, i::AbstractArray)\n\n\n[x] new testing framework with nice reports\n\n\n[x] Setup Documenter.jl - based docs pushed to github by travis\n\n\n[ ] add stable docs badge after next version bump\n\n\n\n\n\n\n\n\nOptimizations\n\n\n\n\n[ ] Re-read julia/base/range.jl, some day understand the meaning of \"# to make StepRange constructor inlineable, so optimizer can see \nstep\n value\"\n\n\n[x] getindex and setindex! optimizations for sorted i, especially for i::UnitRange\n\n\n[ ] Lint clean and test for that\n\n\n[ ] TypeCheck clean (and test for that?)\n\n\n[ ] some trick with start(Range) to make splice! work with scalar int or range\n\n\n[ ] revisit all the array surgery functions like splice!, factor out common elements, try to use resize and copy. Try to centralize the merging of two things, checking for shared runvalues at the ends.\n\n\n[x] try optimizing rwidth and rfirst by copying x.runends and then modifying the copy in place\n\n\n[x] much faster rwidth and rfirst\n\n\n[x] get vcat and sort out of disjoin, especially sort\n\n\n[ ] Everything seems to have a special case for length \n 2 Rles. Is there some way to make those unnecessary globally?\n\n\n[x] custom O(n) disjoin\n\n\n[x] ree, bottleneck is making the return tuple. Do ree! and update an Rle?\n\n\n[x] use sort for median rather than collect, use i = fld(n,2) + 1 for odd n ...\n\n\n[x] look for places where I can use isempty instead of length. 2X speed of nrun(x) == 0 and 4X speed of length(x) == 0\n\n\n[x] findmin\n\n\n[x] findmax\n\n\n[x] findin\n\n\n[x] indexin\n\n\n[ ] can I do setindex(x::Rlevector, i, indices::Array) and such with an iterator that feeds \"ree\"?  Sort incoming indices and values of course.\n\n\n[x] add a few special cases to the \"punt else\" to work towards not punting\n\n\n[ ] setindex!(rle::RLEVector, value, i::UnitRange), can I merge this with the scalar i case using i:i?\n\n\n[x] Inherit from AbstractVector so I can get all the new free AbstractVector indexing\n\n\n[ ] Should logical indexing become indexing with an array of Ranges?\n\n\n[ ] implement Selection algorithm for median: https://en.wikipedia.org/wiki/Selection_algorithm\n\n\n[ ] while true break for ree and numruns?\n\n\n[x] rle + rle spends all its time doing ind2run\n\n\n[x] Do disjoin from 1 towards n so that we can use resize! to shrink and account for shorter length due to ties rather than using disjoin_length.\n\n\n[x] More tests for similar using 2 or 3 args\n\n\n[x] Add badges to README\n\n\n[x] Codecov.io\n\n\n\n\n\n\nBugs\n\n\n\n\n[x] fix mode, needs to do table not just which.max\n\n\n[x] fix vcat, what about merging adjacent runs?\n\n\n[x] binary_functions list not all commutative, split up, mabye set operations separately\n\n\n[x] changes to ree cause reversions in insert and splice\n\n\n[x] Fix group generics definitions to get rid of ambiguous method warnings\n\n\n[x] something is wrong with the iterator, which breaks sum and mean\n\n\n[x] something in splice and insert\n\n\n[x] ree(runvalues,runends) needs to avoid modifying input\n\n\n[x] do I need a print_matrix method to make auto-printing work? print and show work fine.\n\n\n[x] Do I need Base.linearindexing{T\n:MyArray}(::Type{T}) = LinearFast()\n\n\n[x] median with an Int RLE is type unstable, div by 2 gives float otherwise Int\n\n\n[x] setindex!(rle, 801:900, 1:100) does setindex!(rle::RLEVector, value, indices::UnitRange) rather than looking for a two vector method\n\n\n[x] It seems that one cannot make a vector of RLEVectors\n\n\n[x] intersect should maintain multiplicity of 1st arg\n\n\n[x] new disjoin-based group ops does not work for .\n and friends as it does scalar ops inside a loop\n\n\n[ ] findin and findmax seem to have type stability problems\n\n\n[x] rfirst(x,i) also has type stability issues\n\n\n[ ] Should RLEVector() have a runvalue of [0] or []?  It is the former at the moment.\n\n\n\n\n\n\nInitial features for V0.1.0\n\n\n\n\n[x] Examples in toplevel README\n\n\n[x] Some bleeping unit tests already!  It's time.\n\n\n[x] Test for types\n\n\n[x] Test for collections\n\n\n[x] Test for indexing\n\n\n[x] Test for describe\n\n\n[x] Test for math\n\n\n[x] Tests for utils\n\n\n[x] Split RLEVectors.jl into multiple files by subject. It's getting unweildy.\n\n\n[x] conversion of RLEVector{T} to Vector{T}\n\n\n[x] runind or findRun or whichRun method, return index or (index,offset)\n\n\n[x] how does julia do R's table? R's S4vectors doesn't do table(rle1,rle2), but wants to\n\n\n[x] Set operations like setdiff, union, symdiff\n\n\n[x] rle method on Rle, drop zero length runs and join runs with same value\n\n\n[x] clarity on zero-length runs. OK? start and end == 1? What would value be (would I need to get myself involved with DataArrays and Nullable do do this?)\n\n\n[x] in initializer check incoming runends are sorted\n\n\n[x] initializer checks incoming runends are stricly increasing, would be nice to use issorted with a new comparator\n\n\n[x] rep utility to match R's\n\n\n[x] more vector funs: head, tail\n\n\n[x] getindex and setindex! for i::AbstractArray\n\n\n[x] deleteat!\n\n\n[x] splice!\n\n\n[x] inverse_rle method for RLEVector, use in collect etc., skip rwidth\n\n\n[x] fix setindex when on end of run, check for zero length run\n\n\n[x] resize!\n\n\n[x] constructor that takes bitarray and converts to bool array: convert(Vector{Int32},bob)\n\n\n[x] sorting including sort, issorted, reverse and sortperm\n\n\n\n\n\n\nDecisions\n\n\n\n\n[x] Decide when getindex gives an Vector or an RLEVector, be consistent\n\n\n[x] How do I set up the type hierarchy?  a.  How do I share common code as high in the tree as possible? (wait for new features of abstract types in 0.4?)  b.  Can I make it a subtype of Vector and get lots of the Vector  API for free?  Can I then use it in other places that take a  vector? Like a DataFrame column?\n\n\n\n\n[x] How do I represent the runs? length, end, start/end?\n\n\nend allows for direct binarysearch for indexing and makes size a simple lookup   Gives 5X speedup for size, 40X for indexing on RLEVector(int([1:1:1e3]),int([1:1:1e3]))   19956X speedup over R (more efficient algo here though) for     foo = Rle( seq(1,1000,5), rep.int(5,200) )     l = 1:1e3; system.time( for(i in l) { foo[100] } )       vs.     foo = IntegerRle([ int(linspace(1,1000,200)) ], [ int(linspace(1,1000,200)) ])     @time for i in 1:1e3 foo[100] end     2000X speedup for foo + 4\n  * [x] Is there a strictly increasing and positive int vector type I can leverage or make for the runs?      Maybe something that could be linked to the values?  OrderedSet, IntSet?      For disjoin operations, it will be useful to know the unique runends in two+ sets of runs      Would be nice to have disjoin for RLEVector and RunEnds and IRanges and GRanges types\n  * [x] What do I call the getters and setters? I want to use same getters for RLEs and GRanges and such.   begin, end and start are taken. first, step, and last make sense because of what they mean for ranges, but they would mean something else for a Vector   Maybe confusion between Ranges and Vector API means that I should just make my own and use rangestart, rangewidth, rangeend or rfirst, rwidth and rlast. With the latter, the 'r' could be range or run.\n\n\n\n\n\n\nMaybe starts, widths, ends?\n\n\n\n\n\n\n\n\n[x] Is it a good idea to require two arg vectors to be the same length like this: function bob{T1,T1,N}(x::Vector{T1,N},y::Vector{T2,N})  ?  Or just test the lengths and throw an ArgumentError?\n\n\n\n\n\n\n[x] Is 1 an appropriate start for an empty RLEVector? Does that imply that there is a value associated? Go to zero-based, half open (#can-of-worms)?. NO.\n\n\n\n\n[x] does one export methods defined on generics from Base?\n\n\n[x] similar. What would length arg do?  length, nrun, always return an empty one?\n\n\n[x] better naming for runindex, ind2run\n\n\n[x] maybe drop ree!(x::RLEVector) for a ree that returns a tuple of cleaned up runvalues and runends? With the new 0.4 tuple hotness performance won't matter anymore (right?)\n\n\n[x] when incoming runvalues for RLEVector creation is a BitArray (like from .\n) where do I unpack it? Probably best during ree, because it will probably get shorter. Use numruns(runvalues) then deal with 0-len runs separately?\n\n\n[x] What type to return for a slice of an RLEVector?\n\n\n[x] likewise, maybe ind2range(RLEVector, UnitRange) should return a UnitRange", 
            "title": "TODO"
        }, 
        {
            "location": "/TODO/#todo-list", 
            "text": "", 
            "title": "TODO list"
        }, 
        {
            "location": "/TODO/#new-types", 
            "text": "[ ] Vector{RLEVector} called RLEVectorList (RVL) with group_generics that loop over elements and match elements when given two RLEs  [ ] RLEDataFrame based on RLEVectorList  [ ] RVL implements all RLEVector functions as map(x,rvl)  [ ] which functions apply to the list and which map over the elements?  [ ] RLEDF needs the same creation functions as DataFrame", 
            "title": "New types"
        }, 
        {
            "location": "/TODO/#05-changes", 
            "text": "[x] Base.:(symbol) should now be Base.:symbol, requiring some changes in group_generics.jl  [x] BaseTestNext  [x] different show for MIME type for printing in REPL", 
            "title": "0.5 changes"
        }, 
        {
            "location": "/TODO/#enhancements", 
            "text": "[ ] Figure out how Documenter and doctests work together  [ ] for f in  [:sum, :prod, :mean, :var, :std] @eval mapslices(f::typeof(:f), A, dims) = :f(A, dims) end  [ ] Make Runs type, split from and use in RLEVector  [x] pretty  show  with elipsis if length   6, show runs and also expanded vector, use utils.rep  [x] Add benchmark/ with R and .jl scripts comparing timings on some common things. Have one read a CSV from the other and plot.  [ ] outer constructor for RLEVectors that takes runends or vector and then optional named args runends and runwidths  [ ] Can I make a special zip-like loop that runs over the disjoint runs of 2+ RLEVectors and the associated values?  [ ] vcat with splat for multiple args (vararg vcat)  [x] deleterun! should give a ree'd RLEVector, check for newly adjacent runs, use deleteat![x,itr] if necessary  [x] Any other function groups from DataArrays that I need?  [x] factor out run counting stuff in ree(Vector) and disjoin, call it  nrun  [x] implement comparison operators  =, etc.  [x] Rle to set conversion  [ ] iterator versions of rwidth and rstart. Allocation is the root of all evil. Allocation in rwidth seems to be the bulk of 'median' at this point, for example.  [x] ind2runcontext for UnitRange, use for setindex(x::RLEVector, value, indices::UnitRange)  [x] Make sure this works with Julia V0.4. Likely we have some tuple trouble and the tests will be riddled with the Range expansion change ([1:4] is a 1-vector of Ranges rather than [1,2,3,4]).  [x] function documentation section: describing  [x] function documentation section: creating  [x] function documentation section: range functions  [ ] get ree and vcat out of splice  [ ] iterator called 'ranges' that gives (first,last) indices for runs. Will require a new type with the 3 iterator methods, say RLERangesIterator.  [x] Make sure my hash and == are what AutoHashEquals would say  [ ] linalg operations  [ ] make 'each' a Task?  [ ] make disjoin Task for two RLEs?  [ ] faster group_generic operations based on disjoin  [ ] Some way to disjoin two RLEs such that the runends are made identical, with some repeated runvalues (necessarily). Should it be OK have an RLE be less than fully compressed? Would 'ree' then re-compress it?  [x] test for ind2run(rle::RLEVector, i::AbstractArray)  [x] new testing framework with nice reports  [x] Setup Documenter.jl - based docs pushed to github by travis  [ ] add stable docs badge after next version bump", 
            "title": "Enhancements"
        }, 
        {
            "location": "/TODO/#optimizations", 
            "text": "[ ] Re-read julia/base/range.jl, some day understand the meaning of \"# to make StepRange constructor inlineable, so optimizer can see  step  value\"  [x] getindex and setindex! optimizations for sorted i, especially for i::UnitRange  [ ] Lint clean and test for that  [ ] TypeCheck clean (and test for that?)  [ ] some trick with start(Range) to make splice! work with scalar int or range  [ ] revisit all the array surgery functions like splice!, factor out common elements, try to use resize and copy. Try to centralize the merging of two things, checking for shared runvalues at the ends.  [x] try optimizing rwidth and rfirst by copying x.runends and then modifying the copy in place  [x] much faster rwidth and rfirst  [x] get vcat and sort out of disjoin, especially sort  [ ] Everything seems to have a special case for length   2 Rles. Is there some way to make those unnecessary globally?  [x] custom O(n) disjoin  [x] ree, bottleneck is making the return tuple. Do ree! and update an Rle?  [x] use sort for median rather than collect, use i = fld(n,2) + 1 for odd n ...  [x] look for places where I can use isempty instead of length. 2X speed of nrun(x) == 0 and 4X speed of length(x) == 0  [x] findmin  [x] findmax  [x] findin  [x] indexin  [ ] can I do setindex(x::Rlevector, i, indices::Array) and such with an iterator that feeds \"ree\"?  Sort incoming indices and values of course.  [x] add a few special cases to the \"punt else\" to work towards not punting  [ ] setindex!(rle::RLEVector, value, i::UnitRange), can I merge this with the scalar i case using i:i?  [x] Inherit from AbstractVector so I can get all the new free AbstractVector indexing  [ ] Should logical indexing become indexing with an array of Ranges?  [ ] implement Selection algorithm for median: https://en.wikipedia.org/wiki/Selection_algorithm  [ ] while true break for ree and numruns?  [x] rle + rle spends all its time doing ind2run  [x] Do disjoin from 1 towards n so that we can use resize! to shrink and account for shorter length due to ties rather than using disjoin_length.  [x] More tests for similar using 2 or 3 args  [x] Add badges to README  [x] Codecov.io", 
            "title": "Optimizations"
        }, 
        {
            "location": "/TODO/#bugs", 
            "text": "[x] fix mode, needs to do table not just which.max  [x] fix vcat, what about merging adjacent runs?  [x] binary_functions list not all commutative, split up, mabye set operations separately  [x] changes to ree cause reversions in insert and splice  [x] Fix group generics definitions to get rid of ambiguous method warnings  [x] something is wrong with the iterator, which breaks sum and mean  [x] something in splice and insert  [x] ree(runvalues,runends) needs to avoid modifying input  [x] do I need a print_matrix method to make auto-printing work? print and show work fine.  [x] Do I need Base.linearindexing{T :MyArray}(::Type{T}) = LinearFast()  [x] median with an Int RLE is type unstable, div by 2 gives float otherwise Int  [x] setindex!(rle, 801:900, 1:100) does setindex!(rle::RLEVector, value, indices::UnitRange) rather than looking for a two vector method  [x] It seems that one cannot make a vector of RLEVectors  [x] intersect should maintain multiplicity of 1st arg  [x] new disjoin-based group ops does not work for .  and friends as it does scalar ops inside a loop  [ ] findin and findmax seem to have type stability problems  [x] rfirst(x,i) also has type stability issues  [ ] Should RLEVector() have a runvalue of [0] or []?  It is the former at the moment.", 
            "title": "Bugs"
        }, 
        {
            "location": "/TODO/#initial-features-for-v010", 
            "text": "[x] Examples in toplevel README  [x] Some bleeping unit tests already!  It's time.  [x] Test for types  [x] Test for collections  [x] Test for indexing  [x] Test for describe  [x] Test for math  [x] Tests for utils  [x] Split RLEVectors.jl into multiple files by subject. It's getting unweildy.  [x] conversion of RLEVector{T} to Vector{T}  [x] runind or findRun or whichRun method, return index or (index,offset)  [x] how does julia do R's table? R's S4vectors doesn't do table(rle1,rle2), but wants to  [x] Set operations like setdiff, union, symdiff  [x] rle method on Rle, drop zero length runs and join runs with same value  [x] clarity on zero-length runs. OK? start and end == 1? What would value be (would I need to get myself involved with DataArrays and Nullable do do this?)  [x] in initializer check incoming runends are sorted  [x] initializer checks incoming runends are stricly increasing, would be nice to use issorted with a new comparator  [x] rep utility to match R's  [x] more vector funs: head, tail  [x] getindex and setindex! for i::AbstractArray  [x] deleteat!  [x] splice!  [x] inverse_rle method for RLEVector, use in collect etc., skip rwidth  [x] fix setindex when on end of run, check for zero length run  [x] resize!  [x] constructor that takes bitarray and converts to bool array: convert(Vector{Int32},bob)  [x] sorting including sort, issorted, reverse and sortperm", 
            "title": "Initial features for V0.1.0"
        }, 
        {
            "location": "/TODO/#decisions", 
            "text": "[x] Decide when getindex gives an Vector or an RLEVector, be consistent  [x] How do I set up the type hierarchy?  a.  How do I share common code as high in the tree as possible? (wait for new features of abstract types in 0.4?)  b.  Can I make it a subtype of Vector and get lots of the Vector  API for free?  Can I then use it in other places that take a  vector? Like a DataFrame column?   [x] How do I represent the runs? length, end, start/end?  end allows for direct binarysearch for indexing and makes size a simple lookup   Gives 5X speedup for size, 40X for indexing on RLEVector(int([1:1:1e3]),int([1:1:1e3]))   19956X speedup over R (more efficient algo here though) for     foo = Rle( seq(1,1000,5), rep.int(5,200) )     l = 1:1e3; system.time( for(i in l) { foo[100] } )       vs.     foo = IntegerRle([ int(linspace(1,1000,200)) ], [ int(linspace(1,1000,200)) ])     @time for i in 1:1e3 foo[100] end     2000X speedup for foo + 4\n  * [x] Is there a strictly increasing and positive int vector type I can leverage or make for the runs?      Maybe something that could be linked to the values?  OrderedSet, IntSet?      For disjoin operations, it will be useful to know the unique runends in two+ sets of runs      Would be nice to have disjoin for RLEVector and RunEnds and IRanges and GRanges types\n  * [x] What do I call the getters and setters? I want to use same getters for RLEs and GRanges and such.   begin, end and start are taken. first, step, and last make sense because of what they mean for ranges, but they would mean something else for a Vector   Maybe confusion between Ranges and Vector API means that I should just make my own and use rangestart, rangewidth, rangeend or rfirst, rwidth and rlast. With the latter, the 'r' could be range or run.    Maybe starts, widths, ends?    [x] Is it a good idea to require two arg vectors to be the same length like this: function bob{T1,T1,N}(x::Vector{T1,N},y::Vector{T2,N})  ?  Or just test the lengths and throw an ArgumentError?    [x] Is 1 an appropriate start for an empty RLEVector? Does that imply that there is a value associated? Go to zero-based, half open (#can-of-worms)?. NO.   [x] does one export methods defined on generics from Base?  [x] similar. What would length arg do?  length, nrun, always return an empty one?  [x] better naming for runindex, ind2run  [x] maybe drop ree!(x::RLEVector) for a ree that returns a tuple of cleaned up runvalues and runends? With the new 0.4 tuple hotness performance won't matter anymore (right?)  [x] when incoming runvalues for RLEVector creation is a BitArray (like from . ) where do I unpack it? Probably best during ree, because it will probably get shorter. Use numruns(runvalues) then deal with 0-len runs separately?  [x] What type to return for a slice of an RLEVector?  [x] likewise, maybe ind2range(RLEVector, UnitRange) should return a UnitRange", 
            "title": "Decisions"
        }, 
        {
            "location": "/api/", 
            "text": "The RLEVectors Types and Methods\n\n\n\n\nIndex\n\n\n\n\nRLEVectors.RLEDataFrame\n\n\nRLEVectors.RLEVector\n\n\nBase.Sort.searchsortedfirst\n\n\nBase.Sort.searchsortedfirst\n\n\nRLEVectors.disjoin\n\n\nRLEVectors.rep\n\n\n\n\n\n\nTypes\n\n\n#\n\n\nRLEVectors.RLEVector\n \n \nType\n.\n\n\nRLEVectors\n\n\nRLEVectors\n is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.\n\n\nRLEVectors\n can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector like a \nRange\n with \ncollect\n.\n\n\nExamples\n\n\n\n\nx = RLEVector([1,1,2,2,3,3,4,4,4])\n\n\nx = RLEVector([4,5,6],[3,6,9])\n\n\n\n\nsource\n\n\n#\n\n\nRLEVectors.RLEDataFrame\n \n \nType\n.\n\n\nAn RLEDataFrame extends DataFrame and contains a colection of like-length and like-type     RLEVectors. In a way, this creates a type like an RLE matrix. But, we deliberately     avoid the complexity of matrix operations, such as factorization. It is expected     that most operations will be column-wise. Based on RleDataFrame from Bioconductor's     \ngenoset\n package (also by Peter Haverty).\n\n\nConstructors\n\n\nDataFrame(columns::Vector{RLEVector},  names::Vector{Symbol})\nDataFrame(kwargs...)\n\n\n\n\nExamples\n\n\nRLEDataFrame( [RLEVector([1, 1, 2]),  RLEVector([2, 2, 2])], [:a, :b] )\n\n\n\n\nsource\n\n\n\n\nWorking with runs and run boundaries\n\n\n#\n\n\nRLEVectors.disjoin\n \n \nFunction\n.\n\n\nTakes runends from two RLEVectors, make one new runends breaking the pair into non-overlapping runs. Basically, this is an optimized \nsort!(unique([x,y])))\n. This is useful when comparing two RLEVector objects. The values corresponding to each disjoint run in \nx\n and \ny\n can then be compared directly.\n\n\nReturns\n\n\nAn integer vector, of a type that is the promotion of the eltypes of the runends of x and y.\n\n\n## Examples\nx = RLEVector([1,1,2,2,3,3])\ny = RLEVector([1,1,1,2,3,4])\nfor (i,j) in disjoin(x,y)\n    println(x[i] + y[j])\nend\n\n\n\n\nsource\n\n\n\n\nStandard Vector API methods\n\n\n\n\nUtility Functions\n\n\n#\n\n\nRLEVectors.rep\n \n \nFunction\n.\n\n\nConstruct a vector of repeated values, just like R's \nrep\n function. We do not have a \nlength_out\n argument at this time.\n\n\nExamples\n\n\nrep([\nGo\n, \nFight\n, \nWin\n], times=2)\n\n# output\n6-element Array{String,1}:\n \nGo\n   \n \nFight\n\n \nWin\n  \n \nGo\n   \n \nFight\n\n \nWin\n  \n\n\n\n\nrep([\nA\n, \nB\n, \nC\n], each=3)\n\n# output\n9-element Array{String,1}:\n \nA\n\n \nA\n\n \nA\n\n \nB\n\n \nB\n\n \nB\n\n \nC\n\n \nC\n\n \nC\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.Sort.searchsortedfirst\n \n \nMethod\n.\n\n\nThe method for two vectors is like R's findinterval.\n\n\nsource\n\n\n#\n\n\nBase.Sort.searchsortedfirst\n \n \nMethod\n.\n\n\nThe four argument version substitutes customized ordering for a hard-coded '\n'.\n\n\nsource", 
            "title": "API"
        }, 
        {
            "location": "/api/#the-rlevectors-types-and-methods", 
            "text": "", 
            "title": "The RLEVectors Types and Methods"
        }, 
        {
            "location": "/api/#index", 
            "text": "RLEVectors.RLEDataFrame  RLEVectors.RLEVector  Base.Sort.searchsortedfirst  Base.Sort.searchsortedfirst  RLEVectors.disjoin  RLEVectors.rep", 
            "title": "Index"
        }, 
        {
            "location": "/api/#types", 
            "text": "#  RLEVectors.RLEVector     Type .  RLEVectors  RLEVectors  is an alternate implementation of the Rle type from Bioconductor's IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a vector with repeated values as the ordered set of values and repeat extents. In the field of genomics, data of various types measured across the ~3 billion letters in the human genome can often be represented in a few thousand runs. It is useful to know the bounds of genome regions covered by these runs, the values associated with these runs, and to be able to perform various mathematical operations on these values.  RLEVectors  can be created from a single vector or a vector of values and a vector of run ends. In either case runs of values or zero length runs will be compressed out. RLEVectors can be expanded to a full vector like a  Range  with  collect .  Examples   x = RLEVector([1,1,2,2,3,3,4,4,4])  x = RLEVector([4,5,6],[3,6,9])   source  #  RLEVectors.RLEDataFrame     Type .  An RLEDataFrame extends DataFrame and contains a colection of like-length and like-type     RLEVectors. In a way, this creates a type like an RLE matrix. But, we deliberately     avoid the complexity of matrix operations, such as factorization. It is expected     that most operations will be column-wise. Based on RleDataFrame from Bioconductor's      genoset  package (also by Peter Haverty).  Constructors  DataFrame(columns::Vector{RLEVector},  names::Vector{Symbol})\nDataFrame(kwargs...)  Examples  RLEDataFrame( [RLEVector([1, 1, 2]),  RLEVector([2, 2, 2])], [:a, :b] )  source", 
            "title": "Types"
        }, 
        {
            "location": "/api/#working-with-runs-and-run-boundaries", 
            "text": "#  RLEVectors.disjoin     Function .  Takes runends from two RLEVectors, make one new runends breaking the pair into non-overlapping runs. Basically, this is an optimized  sort!(unique([x,y]))) . This is useful when comparing two RLEVector objects. The values corresponding to each disjoint run in  x  and  y  can then be compared directly.  Returns  An integer vector, of a type that is the promotion of the eltypes of the runends of x and y.  ## Examples\nx = RLEVector([1,1,2,2,3,3])\ny = RLEVector([1,1,1,2,3,4])\nfor (i,j) in disjoin(x,y)\n    println(x[i] + y[j])\nend  source", 
            "title": "Working with runs and run boundaries"
        }, 
        {
            "location": "/api/#standard-vector-api-methods", 
            "text": "", 
            "title": "Standard Vector API methods"
        }, 
        {
            "location": "/api/#utility-functions", 
            "text": "#  RLEVectors.rep     Function .  Construct a vector of repeated values, just like R's  rep  function. We do not have a  length_out  argument at this time.  Examples  rep([ Go ,  Fight ,  Win ], times=2)\n\n# output\n6-element Array{String,1}:\n  Go    \n  Fight \n  Win   \n  Go    \n  Fight \n  Win     rep([ A ,  B ,  C ], each=3)\n\n# output\n9-element Array{String,1}:\n  A \n  A \n  A \n  B \n  B \n  B \n  C \n  C \n  C   source  #  Base.Sort.searchsortedfirst     Method .  The method for two vectors is like R's findinterval.  source  #  Base.Sort.searchsortedfirst     Method .  The four argument version substitutes customized ordering for a hard-coded ' '.  source", 
            "title": "Utility Functions"
        }
    ]
}