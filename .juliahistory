x
?deleteat!
@timeit setindex!(x, 99, 800:820)
@timeit setindex!(foo, 99, 800:820)
@timeit setindex!(foo, 99, 800:820)
@timeit setindex!(foo, 99, 800:820)
bdf
bdf
bdf
Profile.clear(); @profile foo[800:820] =  4; Profile.print()
@timeit setindex!(foo, 99, 800:820)
@timeit setindex!(foo, 99, 800:820)
@timeit setindex!(foo, 800:820, 800:820)
@timeit setindex!(foo, 800:820, 800:820)
Profile.clear(); @profile foo[800:820] =  800:820; Profile.print()
Profile.clear(); @profile for i in 1:100 foo[800:820] =  800:820; end; Profile.print()
Profile.clear(); @profile for i in 1:1000 foo[800:820] =  800:820; end; Profile.print()
Profile.clear(); @profile for i in 1:10000 foo[800:820] =  800:820; end; Profile.print()
Profile.clear(); @profile for i in 1:100000 foo[800:820] =  800:820; end; Profile.print()
Profile.clear(); @profile for i in 1:1000000 foo[800:820] =  800:820; end; Profile.print()
Profile.clear(); @profile for i in 1:10000000 foo[800:820] =  800:820; end; Profile.print()
x = RLEVector([1,1,2,2,3,3])
bob=800:820; Profile.clear(); @profile for i in 1:10000000 foo[bob] = bob; end; Profile.print()
bob=800:820; Profile.clear(); @profile for i in 1:10000000 foo[bob] = bob; end; Profile.print()
bob=800:820; joe=RLEVector(800:820); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
exit()
Profile.clear(); @profile for i in 1:10000000 foo[800:820] =  800:820; end; Profile.print()
bob=800:820; joe=RLEVector(800:820); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
Pkg.test("RLEVectors")
exit()
bob=800:820; joe=RLEVector(800:820); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
exit()
Profile.clear(); @profile for i in 1:10000000 foo[800:820] =  800:820; end; Profile.print()
bob=800:820; joe = RLEVector(800:820); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
bob=800:820; joe = RLEVector(800:820); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
exit()
bob=800:820; joe = RLEVector(800:820); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
bob=800:820; joe = RLEVector(800:820); Profile.clear(); @profile for i in 1:10000000 foo[bob] = 99; end; Profile.print()
 @time for i in 1:10000000 foo[bob] = 99; end
 @time for i in 1:10000000 foo[bob] = joe; end
 @time for i in 1:10000000 foo[bob] = joe; end
 @time for i in 1:10000000 foo[bob] = joe; end
Profile.clear(); @profile for i in 1:10000000 foo[800:820] =  800:820; end; Profile.print()
Profile.clear(); @profile for i in 1:10000000 foo[800:820] =  800:820; end; Profile.print()
@timeit setindex!(foo, 800:820, 800:820)
@timeit setindex!(foo, 800:820, 800:820)
@timeit setindex!(foo, 800:820, 800:820)
exit()
Pkg.test("RLEVectors")
bdf
@timeit coverage(gr)
@timeit coverage(gr)
bdf
bdf[:,11:end]
Profile.clear(); @profile for i in 1:10000000 foo[800:820] =  800:820; end; Profile.print()
bob=800:820; joe= RLEVectors(bob); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
bob=800:820; joe= RLEVector(bob); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
bob=800:820; joe= RLEVector(bob); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
bob=800:820; joe= RLEVector(bob); Profile.clear(); @profile for i in 1:10000000 foo[bob] = joe; end; Profile.print()
last([])
@timeit coverage(gr)
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
x
x[3]
x[1]
collect(x)
x[1]
x[2]
x[3]
x[4]
x[5]
x[6]
x[7]
x[8]
x[9]
x[10]
x[11]
length(x)
Pkg.test("RLEVectors")
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
x[2:5]
x[2:5]
x[2:5]
x[2:5]
x[2:5]
x
Pkg.test("RLEVectors")
collect(x)
x
x[5]
x[5:7]
collect(x[5:7])
x[5:7]
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
ind = 5:7
x
run_indices
offset
v
e
x
v
e
e
ind2runcontext
?ind2runcontext
x 
indices=5:7
e
v
i
x
v
e
x
x
v
e
v
e
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
x[5:7]
x[5:7]
x[5:7]
Pkg.test("RLEVectors")
Pkg.test("RLEVectors")
@timeit foo[801:900] = 1:100
exit()
Pkg.test("RLEVectors")
bdf[:,11:end]
bdf[:,11:end]
bdf
bdf[:,8:end]
8.29 /  .57
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
x[2:4] = 99
x
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
x[2:6] = 99
x
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
x[2:6] = 99
x
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
x[2:7] = 99
x
Pkg.test("RLEVectors")
x
x
x
value = 4
indices = 9:12
run_right
x
run_left
nrun_out
run_left
run_right
x
x
run_left
((nrun_x - run_right) + 1)
nrun_value
x
value
run_right
nrun_value
right_run
run_right
x = RLEVector([1,1,2,2,3,3,4,4,5,5])
x[2:7] = 99
x
x
x
x
exit()
x
x
value
value = 99
value = 4
indices = 9:12
x
run_remainder_right == 0
run_right < nrun_x && value == x.runvalues[run_right]
x
x
i_right
run_right <= nrun_x && value == x.runvalues[run_right]
x
x
exit()
value = RLEVector(4)
indices = 11:12
x
indices
value = RLEVector(2)
indices = 9:12
indices
value
x
run_right
run_lefg
run_left
x
value
x
indices = 1:2
value = RLEVector([2,2])
x
value
indices
run_left
nrun_value
run_right
x
x
x[3:8] = 1
x
x[3:6] = 1
x[4:6] = 1
x[4:5] = [1,1]
x
x[2:3] = [1,1]
x
x[1:3] = [1,1]
indices = 1:3
value = RLEVector([1,1])
x
indices
value
value = RLEVector([1,1])
indices = 1:3
value = RLEVector([1,1,1])
x.runvalues[run_left] == first(value)
x.runvalues[run_right] == last(value)
run_remainder_right == 0
nrun_out
x
indices
x
x[indices] = value
x
x
indices = 1:2
value = RLEVector([2,2])
run_left
x.runvalues[run_right] == last(value)
run_remainder_right == 0
run_right < nrun_x && last(value) == x.runvalues[run_right]
run_right
x
x
x
length(value.runvalues)
x
collect(x)
x
indices = 2:3
value = RLEVector([2,2])
indices
x.runvalues[run_left] == first(value)
index_in_run_left == 1
x
indices
value
x
run_left
i_left
run_left
x
x.runvalues[run_right] == last(value)
x
x.runvalues[run_right] == last(value)
x
i_right
value.runvalues
run_left
x
i = 1
value.runvalues[i]
x
bump
value.runends[i] + bump
i_right
x
x
indices = 2:3
value = RLEVector([1,1])
x
x
value_runends
x
run_left
run_right
x
value.runends
i_right
value_runends
value_runends
value_runvalues
x
indices
Pkg.test("RLEVectors")
exit()
Pkg.test("RLEVectors")
Pkg.test("RLEVectors")
using RLEVectors
@which setindex!(x, 5, 9:12)
x[9:12] = RLEVector(5)
RLEVector(1,4)
@which setindex!(x, 5, 9:12)
Pkg.test("RLEVectors")
exit()
@which setindex!(x, 5, 10:11)
@which setindex!(x, 5, 10:11)
Pkg.test("RLEVectors")
Pkg.test("RLEVectors")
exit()
Pkg.test("RLEVectors")
@which setindex!(x, 5, 10:11)
@which setindex!(x, RLEVector(5,2), 10:11)
Pkg.test("RLEVectors")
x
value = RLEVector(5,2)
indices = 10:11
x
run_right
run_left
x
x
x.runvalues[run_left] == first(value)
index_in_run_left == 1
run_left > 0 && first(value) == x.runvalues[run_left]
x
run_left
run_right
x.runvalues[run_right] == last(value)
run_remainder_right == 0
x
nrun_value
x
x
x
run_left
x.runvalues[run_right] == last(value)
run_remainder_right == 0
run_right
nrun_value
x
x
run_left
run_right
value
indices
x
nrun_diff > 0
x
bump
nrun_value
x
run_right
nrun_diff
x
x
x
Pkg.test("RLEVectors")
exit()
x
value = RLEVector(2,2)
indices = 9:10
x
x
x
indices
run_left > 0
x
i_left
indices
x
run_left
i_left
i_right
x
values
x
index_in_run_left
exit()
Pkg.test("RLEVectors")
values = RLEVector(2,2)
indices = 9:10
value = RLEVector(2,2)
run_left
x
indices
value
run_right
index_in_run_left
indice
indices
x
x
nrun_diff
x
x
run_left
index_in_run_left
Pkg.test("RLEVectors")
indices = 11:12
value = RLEVector(4,2)
x
value
indices
index_in_run_left
x
bump
x
x
indices
value
x.runvalues[run_right] == last(value)
run_remainder_right == 0
run_right
run_left
x
indices
run_right < nrun_x && last(value) == x.runvalues[run_right]
x
indices
nrun_value
x
x
x.runvalues[run_right] == last(value)
run_remainder_right == 0
nrun_value
run_right
run_right
run_right < nrun_x && last(value) == x.runvalues[run_right]
Pkg.test("RLEVectors")
exit()
indices = 6:7
value = RLEVector([3,3])
x
indices
value
x.runvalues[run_left] == first(value)
x
x.runvalues[run_right] == last(value)
run_remainder_right == 0
i_left
x
x
run_left > 0 && index_in_run_left != 1
index_in_run_left
x
indices
x
indices
x
x
value
indices
Pkg.test("RLEVectors")
x = RLEVector([1,1,1,2,2,2,3,3,3,4,4,4,5,5,5])
x[3:5] = 1
x
exit()
using RLEVectors
using RLEVectors
x = RLEVector([1,1,1,2,2,2,3,3,3,4,4,4,5,5,5])
x[3:5] = 1
x
Pkg.test("RLEVectors")
x = RLEVector([1,1,1,2,2,2,3,3,3,4,4,4,5,5,5])
x[3:5] = 1
x
exit()
using RLEVectors
?UnitRange
UnitRange(1,2)
UnitRange(1,2.0)
UnitRange(1.0,2.0)
exit()
Tuple{Int,Int}
bob = Tuple{Int64,Int64}
typeof(bob)
using RLEVectors
struct RLEVector{T1,T2 <: Integer} <: AbstractArray{T1,1}
  runvalues::Vector{T1}
  runends::Vector{T2}
  RLEVector{T1,T2}(runvalues,runends) where {T1,T2<:Integer} = new(runvalues,runends)
end

struct RLEEachRangeIterator{T1,T2}
    rle::RLEVector{T1,T2}
end
eachrange(x::RLEVector) = RLEEachRangeIterator(x)
eltype(::RLERangeIterator{T1,T2}) where {T1,T2} = Tuple{T2,T2}

struct RLEEachRangeIterator{T1,T2}
    rle::RLEVector{T1,T2}
end

import Base.iterate
foo = RLEVector([1,1])

function RLEVector(runvalues::Vector{T1}, runends::Vector{T2}) where {T1, T2 <: Integer}
    runvalues, runends = ree!(runvalues,runends)
    RLEVector{T1,T2}(runvalues, runends)
end

function RLEVector(runvalues::BitVector, runends::Vector{T2}) where T2 <: Integer
    runvalues, runends = ree!(runvalues,runends)
    RLEVector{Bool,T2}(runvalues, runends)
end

function RLEVector(vec::Vector)
  runvalues, runends = ree(vec)
  RLEVector(runvalues, runends)
end

function RLEVector(x::UnitRange)
    RLEVector{eltype(x),Int64}(collect(x),collect(1:length(x)))
end

function RLEVector(x)
    RLEVector([x])
end

function RLEVector(runvalues::T1, runends::T2) where {T1,T2 <: Integer}
    RLEVector{T1,T2}([runvalues], [runends])
end

foo = RLEVector([1,1])
foo = RLEVector{Int64,Int64}([1,1])
foo = RLEVector{Int64,Int64}(1,2)
foo = RLEVector{Int64,Int64}([1],[2])
### RLEVectorsType

"""
# RLEVectors
`RLEVectors` is an alternate implementation of the Rle type from Bioconductor's
IRanges package by H. Pages, P. Aboyoun and M. Lawrence. RLEVectors represent a
vector with repeated values as the ordered set of values and repeat extents. In
the field of genomics, data of various types measured across the ~3 billion
letters in the human genome can often be represented in a few thousand runs.
It is useful to know the bounds of genome regions covered by these runs, the
values associated with these runs, and to be able to perform various
mathematical operations on these values.

`RLEVectors` can be created from a single vector or a vector of values and a
vector of run ends. In either case runs of values or zero length runs will
be compressed out. RLEVectors can be expanded to a full vector with `collect`.

## Aliases
Several aliases are defined for specific types of RLEVector (or collections thereof).

    FloatRle              RLEVector{Float64,UInt32}
    IntegerRle            RLEVector{Int64,UInt32}
    BoolRle               RLEVector{Bool,UInt32}
    StringRle             RLEVector{String,UInt32}
    RLEVectorList{T1,T2}  Vector{ RLEVector{T1,T2} }

## Constructors
`RLEVector`s can be created by specifying a vector to compress or the runvalues and run ends.

    x = RLEVector([1,1,2,2,3,3,4,4,4])
    x = RLEVector([4,5,6],[3,6,9])

## Describing `RLEVector` objects
`RLEVector`s implement the usual descriptive functions for an array as well as some that are
specific to the type.

* `length(x)` The full length of the vector, uncompressed
* `size(x)` Same as `length`, as for any other vector
* `size(x,dim)` Returns `(length(x),1) for dim == 1`
* `starts(x)` The index of the beginning of each run
* `widths(x)` The width of each run
* `ends(x)` The index of the end of each run
* `values(x)` The data value for each run
* `isempty(x)` Returns boolean, as for any other vector
* `nrun(x)` Returns the number of runs represented in the array
* `eltype(x)` Returns the element type of the runs
* `endtype(x)` Returns the element type of the run ends

"""
struct RLEVector{T1,T2 <: Integer} <: AbstractArray{T1,1}
  runvalues::Vector{T1}
  runends::Vector{T2}
  RLEVector{T1,T2}(runvalues,runends) where {T1,T2<:Integer} = new(runvalues,runends)
end

function RLEVector(runvalues::Vector{T1}, runends::Vector{T2}) where {T1, T2 <: Integer}
    runvalues, runends = ree!(runvalues,runends)
    RLEVector{T1,T2}(runvalues, runends)
end

function RLEVector(runvalues::BitVector, runends::Vector{T2}) where T2 <: Integer
    runvalues, runends = ree!(runvalues,runends)
    RLEVector{Bool,T2}(runvalues, runends)
end

function RLEVector(vec::Vector)
  runvalues, runends = ree(vec)
  RLEVector(runvalues, runends)
end

function RLEVector(x::UnitRange)
    RLEVector{eltype(x),Int64}(collect(x),collect(1:length(x)))
end

function RLEVector(x)
    RLEVector([x])
end

function RLEVector(runvalues::T1, runends::T2) where {T1,T2 <: Integer}
    RLEVector{T1,T2}([runvalues], [runends])
end

#  Having specific types of Rle would be useful for lists of the same type, but Julia does a good job noticing that
#  Could also be useful for method definitions
const FloatRle = RLEVector{Float64,UInt32}
const IntegerRle = RLEVector{Int64,UInt32}
const BoolRle = RLEVector{Bool,UInt32}
const StringRle = RLEVector{String,UInt32}
const RLEVectorList{T1,T2} = Vector{ RLEVector{T1,T2} }
@doc (@doc RLEVector) FloatRle,  IntegerRle, BoolRle, StringRle, RLEVectorList

# similar
function similar(x::RLEVector, element_type::Type, dims::Dims)
    len = dims[1]
    if len == 0
        return( RLEVector(element_type[], eltype(x.runends)[]) )
    else
        return( RLEVector(zeros(element_type, 1), eltype(x.runends)[len]) )
    end
end

# show
function Base.show(io::IO, ::MIME"text/plain", x::RLEVector)
    t = typeof(x)::DataType
    show(io, t)
    n = nrun(x)
    write(io,"\n Run values: ")
    Base.show_vector(io,x.runvalues,"[", "]")
    write(io,"\n Run ends: ")
    Base.show_vector(io,x.runends,"[", "]")
end

function Base.show(io::IO, x::RLEVector)
    write(io,"Values: ")
    Base.show_vector(io,values(x),"[", "]")
    write(io," Ends: ")
    Base.show_vector(io,ends(x),"[", "]")
end

function ree!(x::RLEVector)
    ree!(x.runvalues,x.runends)
end

# conversions
convert(::Type{Vector}, x::RLEVector) = collect(x)
convert(::Type{Set}, x::RLEVector) = Set(values(x))
convert(::Type{RLEVector}, x::Vector) = RLEVector(x)
promote_rule(::Type{Set}, ::Type{RLEVector}) = Set

# the basics
function collect(x::RLEVector)
  inverse_ree(x.runvalues,x.runends)
end

function isequal(x::RLEVector, y::RLEVector)
isequal(x.runends,y.runends) && isequal(x.runvalues, y.runvalues)
end

Base.hash(a::RLEVector) = hash(a.runvalues, hash(a.runlengths, hash(:RLEVector)))
==(a::RLEVector, b::RLEVector) = isequal(a.runvalues, b.runvalues) && isequal(a.runends, b.runends) && true

"""
    growat!(x::AbstractVector, i, insert_length)
    growat!(x::RLEVector, i, insert_length)
Increases length of vector by `insert_length` at index `i` while
moving values `i:n` down to accomodate the new spaces. For the
`RLEVector` method `insert_length` uninitialized *runs* are added.
"""
function growat!(x::AbstractVector, i, insert_length)
    len = length(x)
    resize!(x, len + insert_length)
    ind = len
    @inbounds for ind in len:-1:i
        x[ind + insert_length] = x[ind]
    end
    x
end

function growat!(x::RLEVector, i, insert_length)
    growat!(x.runvalues, i, insert_length)
    growat!(x.runends, i, insert_length)
    x
end

foo = RLEVector{Int64,Int64}([1],[2])
exit()
